<html>
<head>
    	<title>Kevin Zeidler</title>
	<!-- <link rel="stylesheet" type="text/css" href="style.css"> -->
<style>
			body {
				margin: 0px 0px;
				background-color: #eeead5;
			}

			header {
				position: fixed;
				height: 100px;
				width: 100%;
				overflow: hidden;
				 -webkit-transition: height 0.3s;
			    -moz-transition: height 0.3s;
			    -ms-transition: height 0.3s;
			    -o-transition: height 0.3s;
			    transition: height 0.3s;
			    background-color: #eeead5;
			    z-index: 1000;
			}

			header.full h1#logo {
			    position: relative;
			    height: 100px;
			    top: 42px;
			    bottom:0px;
			    width:33%;
			    font-family: "OpenSans-CondLightItalic", "TradeGothicLTCom-Bd2", "Maven Pro", sans-serif;
			  	background-image: url('http://www.searchandcipher.com/images/kevin-zeidler-logo-clear.png');
			    line-height: 20x;
			    color: #d24209;
			    text-transform: uppercase;
			    float: bottom left;
			    vertical-align: bottom;
				background-size: contain;
				background-repeat: no-repeat;
				text-transform: uppercase;
				font-size: 24px;
				-webkit-transition: all 0.3s;
			    -moz-transition: all 0.3s;
			    -ms-transition: all 0.3s;
			    -o-transition: all 0.3s;
			    transition: all 0.3s;
			}
			header.full a {
				color: #d24209;
			}

			header.full a:hover {
				color: #ff8e68;
			}

			header.full nav {
			    display: inline-block;
			    float: right;
			}
			header.full nav a {
			    line-height: 40px;
			    margin-left: 20px;
			    color: #d24209;
			    font-weight: 700;
			    font-size: 18px;
			    -webkit-transition: all 0.3s;
			    -moz-transition: all 0.3s;
			    -ms-transition: all 0.3s;
			    -o-transition: all 0.3s;
			    transition: all 0.3s;
			}
			header.full nav a:hover {
			    color: white;
			}
			header.smaller {
				position: fixed;
				top: 0;
				margin: 0 auto;
				background-image: url('http://www.searchandcipher.com/images/kevin-zeidler-logo-clear.png');
				background-size: contain;
				background-repeat: no-repeat;
				text-transform: uppercase;


			    height: 30px;
			}
			header.smaller h1#logo {
			    width: 400px;
			    height: 30px;
			    line-height: 30px;
			    font-size: 14px;
			}
			header.smaller nav a {
			    line-height: 30px;
			}

			@media all and (max-width: 660px) {
		    header.full h1#logo {
		    	position:relative;
		        display: block;
		        float: left;
		        vertical-align: bottom;
		        margin: 0 auto;
		        height: 30px;
		        line-height: 30px;
		        text-align: center;
		    }
		    header.full nav {
		        display: block;
		        float: none;
		        height: 50px;
		        text-align: center;
		        margin: 0 auto;
		    }
		    header.full nav a {
		        line-height: 15px;
		        margin: 0 10px;
		    }
		    header.smaller {
		    	position: absolute;
		    	margin: 0 auto;
		    	top: 0;

		        height: 30px;
		    }
		    header.smaller h1#logo 
		   {
		   		z-index: 1000;
		   		top: 0;
		        height: 18px;
		        line-height: 18px;
		        font-size: 18px;
		        float: top left;
		        
		    }
		    header.smaller nav {
		        height: 30px;
		    }
		    header.smaller nav a {
		        line-height: 18px;
		    }
		}
		#text {
			position: relative;
			top: 100px;
			margin: 30px 30px;
		}

			#name {
				position: relative;
				padding-top: 0px;
			}

			#webGL {
				position: relative;
				top: 100px;
				left: 0px;
				width: 100%;
				height: 80%;
				background-image: url('http://www.searchandcipher.com/images/matisse-bg-noaxesHD.jpg');
				background-repeat: no-repeat;
				background-position: center;
				z-index: 10;
				
			}
			#info {
			    text-align:center;
			    color:#000;
			    position: absolute;
			    top: 85px; width: 100%;
			    padding: 0px;
			}
			#data {
			    text-align:center;
			    color:#000;
			    position: absolute;
			    top: 150px; 
			    width: 100%;
			    top-margin: 100px;
			    padding: 0px;
			}
			#content {
				display: inline-block;
				position: relative;
				margin: 600px 100px;

				
			}

			#textoverlay {
				font-family: "OpenSans-CondLightItalic";
				font-size: 20px;
				
			}

			#textoverlay.active {
				opacity: 1;
				color: white;
				-webkit-transition: opacity 0.3s linear;
			    -moz-transition: opacity 0.3s linear;
			    -ms-transition: opacity 0.3s linear;
			    -o-transition: opacity 0.3s linear;
			    transition: opacity 0.3s linear;
			}
			#textoverlay.inactive {
				opacity: 0;
				-webkit-transition: opacity 0.3s linear;
			    -moz-transition: opacity 0.3s linear;
			    -ms-transition: opacity 0.3s linear;
			    -o-transition: opacity 0.3s linear;
			    transition: opacity 0.3s linear;
				
			}
				    
		   
		}



		</style>
		<script src="three.min.js"></script>

		<link href='https://fonts.googleapis.com/css?family=Maven+Pro:400,700,900' rel='stylesheet' type='text/css'>
	</head>
	
	<header class="full">
    <div class="container clearfix">
        <h1 id="logo"><!-- KEVIN ZEIDLER | <a href ="http://www.twitter.com/kevinzeidler">@KevinZeidler</a> --></h1>
        <nav>
            <a href="">CV</a>
  <!--           <a href="">Ipsum</a>
            <a href="">Dolor</a> -->
        </nav>
    </div>
</header><!-- /header -->
<body>
		<div id="WebGL">
		<div id="data">
		<div id="text" class="inactive">
			<h3></h3>
		</div>
		
		</div>

		
		


		<script>

			var t, postCollision;

			var container, stats, bodies, canvas;

			var camera, scene, light, scene2, renderer, canvas, geodesics, box, axes, bbox, geometry, axislengths, flyinggif, cubeArray, velocityVector;

			var dy, dx, dz, tick;

			var cube, plane, picture, cube2, boxshit, cubeGeometry, vertArray, position, observerMass, geocubes, endpoints, maxY, zRotation, yRotation, xRotation;

			var targetRotation = 0;
			var targetRotationOnMouseDown = 0;

			var xVel, yVel, zVel;

			var mouseX = 0;
			var mouseXOnMouseDown = 0;

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;
			


			init();
			console.log(geodesics);
			animate();

			function init() {
				postCollision = false;

				canvas = document.getElementById('WebGL');
				document.body.appendChild( canvas );
				var info = document.createElement( 'div' );
				info.setAttribute("id", "data");
				// info.style.position = 'relative';
				info.style.top = '100px';
				info.style.width = '100%';
				info.style.textAlign = 'center';
				info.innerHTML = '&nbsp';
				canvas.appendChild( info );

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.y = 150;
				camera.position.z = 500;

				scene = new THREE.Scene(); 

				t = initializeTime();
				// cerulean blue: 1197936 
				// emerald green: 1216917
				// scarlet red: 12919556
				// peacock: 304837
				// mustard: 12944388
				// a lighter yellow: 15842572
				// burnt orange: 13256195

				// Cube
				var colors = [1197936, 1197936, 1216917, 1216917, 12919556, 12919556, 14461702, 14461702, 13256195, 13256195, 1216917, 13256195];
				geometry = new THREE.BoxGeometry( 100, 100, 100 );

				var light = new THREE.DirectionalLight(0xFFFFFF, .5);
				light.position.set(200, 500, 200);
				scene.add(light);
				var light = new THREE.DirectionalLight(0xFFFFFF, .5);
				light.position.set(-200, -500, -200);
				scene.add(light);

				var hemiLight = new THREE.HemisphereLight(0x0000ff, 0x00ff00, .6);
				cubeArray = [];
				maxY = new Array();
				dx = new Array();
				dz = new Array();
				xRotation = new Array();
				yRotation = new Array();
				zRotation = new Array();

				initializeFinale(10,-200, 0);
				console.log(dx, maxY);
				

				dy = 10;
				// dz = 0;
				tick = 0;


				for ( var i = 0; i < geometry.faces.length; i += 2) {
					var hex = colors[i];
					geometry.faces[ i ].color.setHex( hex );
					geometry.faces[ i + 1 ].color.setHex( hex );
				}
				observerMass = 500;
				var xUnits = 400;
				var xSkew = 1.0;
				var numCubes = 10;

				var width = (xUnits * xSkew) / numCubes;



				var material = new THREE.MeshBasicMaterial( {  vertexColors: THREE.FaceColors, overdraw: 0.5});
				for (var i = 0; i < cubeArray.length; i++) {

					cubeArray[i] = new THREE.Mesh( geometry, material);
					cubeArray[i].position.x = (i * width) - (.5 * xUnits);
					cubeArray[i].position.y = -300;
					cubeArray[i].position.z = 200;
					maxY[i] = randRange(400,600);
					dx[i] = randRange(0,200)-100;
					dz[i] = randRange(0,100)-50;
					zRotation[i] = randRange(0,200)-100;
					yRotation[i] = randRange(0,200)-100;
					xRotation[i] = randRange(0,200)-100;
					scene.add(cubeArray[i]);
				}

				console.log(cubeArray);
				cube = new THREE.Mesh( geometry, material );
				cube.position.y = 100;
				scene.add( cube );


				// // Cube Shadow
				var geometry = new THREE.PlaneBufferGeometry( 120, 120 );
				geometry.rotateX( - Math.PI / 2 );
				var material = new THREE.MeshBasicMaterial( {  color: 15657685, overdraw: 0.5 } );
				plane = new THREE.Mesh( geometry, material );
				scene.add( plane );

				// Hang a classy painting on the wall perpendicular to the camera (parallel to z-axis)
				var imgurl = 'http://i.imgur.com/LKi1Eir.jpg' //DEV ONLY 'cause localhost objects to loading images from fileserver
				THREE.ImageUtils.crossOrigin = '';
				var texture = THREE.ImageUtils.loadTexture(imgurl);
				var material = new THREE.MeshBasicMaterial({   
				    map: texture,
				});

				picture = new THREE.Mesh( new THREE.PlaneGeometry( 300, 200, 0) , material );
				picture.position.x = -300;
				picture.position.y = 200;
				picture.position.z = 300;
				picture.rotation.y = -2;
				picture.position.z = 0;
				picture.overdraw = true;
				picture.doubleSided = true;
				picture.material.side = THREE.DoubleSide;
				scene.add(picture);

				renderer = new THREE.WebGLRenderer({ alpha: true });
				renderer.setClearColor(  0xffffff, 0);
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				canvas.appendChild( renderer.domElement );
				renderer.autoClear = true;

				// Coordinate axes
				var meshMaterial = new THREE.MeshBasicMaterial({ color: 0xFF00FF, wireframe: true });
	
				camera.lookAt( new THREE.Vector3( 0, 0, 0 ) );
				
				document.addEventListener( 'mousedown', onDocumentMouseDown, false );
				document.addEventListener( 'touchstart', onDocumentTouchStart, false );
				document.addEventListener( 'touchmove', onDocumentTouchMove, false );

				window.addEventListener( 'resize', onWindowResize, false );
				window.addEventListener('scroll', function(e){
			        var distanceY = window.pageYOffset || document.documentElement.scrollTop,
			            shrinkOn = 60,
			            headstatus = document.querySelector("header");
			        if (distanceY > shrinkOn) {
			           document.getElementsByTagName('header')[0].className="";
			           document.getElementsByTagName('header')[0].className = "smaller";

			        } else {
			            if (headstatus == "smaller") {
			            	document.getElementsByTagName('header')[0].className="";
			            	//ah now I see why canonical instance is usually a null class. this is pretty ugly
			            	document.getElementsByTagName('header')[0].className="full";
			            }
			            
			        }
    			});
			}

			function initializeFinale(numCubes, yStart, zStart) {
				colors = [1197936, 1197936, 13256195, 14461702, 12919556, 12919556, 14461702, 14461702, 13256195, 13256195, 1216917, 13256195];

				var xUnits = 800;
				var xSkew = 1.2

				var width = (xUnits * xSkew) / numCubes;

				for (var i = 0; i < numCubes; i++) {
					geometry = new THREE.BoxGeometry( 25, 25, 25 );
					var hexIndex = randRange(0, colors.length);
					var object = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial() );
					for ( var i = 0; i < geometry.faces.length; i += 1) {
						var hex = randRange(0,colors.length) 
						geometry.faces[ i ].color.setHex( colors[hex] );
					}

					object.position.x = (i * width) - (.5 * xUnits);
					object.position.y = yStart;
					object.position.z = zStart;
					scene.add(object);
					cubeArray[i] = object;
					
					maxY[i] = randRange(400,600);
					dx[i] = randRange(0,200)-100;
					dz[i] = randRange(0,100)-50;
					zRotation[i] = randRange(0,200)-100;
					yRotation[i] = randRange(0,200)-100;
					xRotation[i] = randRange(0,200)-100;
					// scene.add(cubeArray[i]);
					
				}
				return cubeArray;
			}


			function degreesToRadians(angleDegrees) {
				return angleDegrees * Math.PI / 180.0;
			}

			function initializeEndpoints() {
				for (var i = 0; i < cubeArray.length; i++) {
					var radians = degreesToRadians(randRange(0,360));
					var radius = randRange(0, 100);
					endpoint = generateEndpoint(cubeArray[i], radians, radius);
					endpoints.push(endpoint);
				}
				return endpoints;
			}

			function generateEndpoint(objStart, angleRadians, radius) {
				var x1 = objStart.position.x;
				var y1 = objStart.position.y;
				var z1 = objStart.position.z;

				x2 = radius + Math.cos(angleRadians)*x1;
				y2 = radius + Math.sin(angleRadians)*y1;
				z2 = z1;

				return new THREE.Vector3(x2,y2,z2);
			}

			function randRange(min, max) {
				return Math.floor(Math.random() * max) + min;
			}

			function whereAre(arrayname) {
				//utility method for showing the position coordinates of each element of the array
				if (arrayname) {
					for (var i = 0; i < arrayname.length; i++) {
						console.log("Element", i, "of", arrayname, "is: ", arrayname[i].position);
					}
				}
				else {

					console.log("Bad array.")
				}
			}

			function axeHelper (length) {
				if (axes) {
					var geometry = new THREE.Geometry();
					var newaxes = buildAxes(t);
					axes = geometry.mergeVertices(newaxes, axes);
					return axes;
				} else {
					axes = buildAxes(length);
				}
				return axes;
			}

			function buildAxes( length ) {
		        axes = new THREE.Object3D();
		        axes.dynamic = true;

		        axes.add( buildAxis( new THREE.Vector3( -160, 60, 0 ), new THREE.Vector3( length-160, 60, 0 ), 15657685, false, "+x" ) ); // +X
		        axes.add( buildAxis( new THREE.Vector3( -160, 60, 0 ), new THREE.Vector3( -length-160, 60, 0 ), 15657685, true, "-x") ); // -X
		        axes.add( buildAxis( new THREE.Vector3( -160, 60, 0 ), new THREE.Vector3( -160, length+60, 0 ), 15657685, false, "+y" ) ); // +Y
		        axes.add( buildAxis( new THREE.Vector3( -160, 60, 0 ), new THREE.Vector3( -160, -length+60, 0 ),15657685, true, "-y" ) ); // -Y
		        axes.add( buildAxis( new THREE.Vector3( -160, 60, 0 ), new THREE.Vector3( -160, 60, length ), 15657685, false, "+z" ) ); // +Z
		        axes.add( buildAxis( new THREE.Vector3( -160, 60, 0 ), new THREE.Vector3( -160, 60, -length ), 15657685, true, "-z" ) ); // -Z

		        scene.add(axes);
		       
		        return axes;

			}

			function scaleAxes(length) {
				for (var i = 0; i < axes.children.length; i++) {
					console.log("The ", i, "th child of axes is:", axes.children[i], "with attributes");
				}

				var tmp = axes.children[0].geometry.vertices[1].add(new THREE.Vector3(t, 0, 0));
				var origin = new THREE.Vector3( -160, 60, 0 );
				axes.children[0].geometry.vertices[1].set(buildAxis(origin, tmp, 15657685, true, "-x"));
				axes.children[0].geometry.verticesNeedUpdate = true;
				axes.children[1].geometry.vertices[1].add(new THREE.Vector3(-t, 0, 0));
				axes.children[1].geometry.verticesNeedUpdate = true;
				
				return axes;
			}

			function initializeTime() {
				// just your everyday basic, global, monotonically increasing constant
				var t = 0;
				return t;
			}

			function buildAxis( src, dst, colorHex, dashed, label ) {
		        var geom = new THREE.Geometry(),
		            mat; 

		        if(dashed) {
		                mat = new THREE.LineDashedMaterial({ linewidth: 1, color: colorHex, dashSize: 1, gapSize: 3 });
		        } 

		        else {
		                mat = new THREE.LineBasicMaterial({ linewidth: 1, color: colorHex });
		        }

		        geom.vertices.push( src.clone() );
		        geom.vertices.push( dst.clone() );
		        geom.computeLineDistances();

		        var axis = new THREE.LineSegments( geom, mat );
		        return axis;
			}

			function onWindowResize() {
				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function onDocumentMouseDown( event ) {
				event.preventDefault();

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'mouseup', onDocumentMouseUp, false );
				document.addEventListener( 'mouseout', onDocumentMouseOut, false );

				mouseXOnMouseDown = event.clientX - windowHalfX;
				targetRotationOnMouseDown = targetRotation;
			}

			function onDocumentMouseMove( event ) {
				mouseX = event.clientX - windowHalfX;

				targetRotation = targetRotationOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.02;
			}

			function onDocumentMouseUp( event ) {
				document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
				document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
				document.removeEventListener( 'mouseout', onDocumentMouseOut, false );
			}

			function onDocumentMouseOut( event ) {
				document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
				document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
				document.removeEventListener( 'mouseout', onDocumentMouseOut, false );
			}

			function onDocumentTouchStart( event ) {
				if ( event.touches.length === 1 ) {

					event.preventDefault();

					mouseXOnMouseDown = event.touches[ 0 ].pageX - windowHalfX;
					targetRotationOnMouseDown = targetRotation;
				}
			}

			function onDocumentTouchMove( event ) {
				if ( event.touches.length === 1 ) {

					event.preventDefault();

					mouseX = event.touches[ 0 ].pageX - windowHalfX;
					targetRotation = targetRotationOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.05;
				}
			}

			function animate() {
				requestAnimationFrame( animate );
				render();
			}
			
			function render() {
				t += 1;
				// var geometry = new THREE.Geometry();
				plane.rotation.y = cube.rotation.y += ( targetRotation - cube.rotation.y + cube.rotation.z ) * 0.05;
				plane.rotation.z += cube.rotation.z;
				plane.position.z += .04 + cube.position.z*.01;
				plane.position.x = cube.position.x;
			
				plane.rotation.x += 0.00001
				if (t < 200) {
					axes = axeHelper(t*t*.05);	
				}

				camera.position.x += .01;
				camera.position.y += .1;
				camera.position.z = 400 - 2*tick*tick/10000;
				camera.rotation.x -= 0.000241661154;
				camera.rotation.y += .0002;
				camera.rotation.z += .00007;
				var duration = 1600;
				var yMax = 1000;

				if (cube.position.z > camera.position.z) {
					// once cube is outside the initial viewport, set the collision flag to true so we don't have to keep checking
					postCollision = true; 
					// camera.position.z *= 1.4;
					var fixed = camera.position.z;
				}

				if (postCollision) {

					for (var i = 0; i < cubeArray.length; i++) {

						dy = maxY[i]*7 - (9.8 * cubeArray[i].position.y);

						if ((cubeArray[i].position.x  < -160)) {
							console.log("This hit the wall: ", cubeArray[i]);
							dx[i] += 300;
						}

						cubeArray[i].position.y += (dy * .0098 - (2*tick*tick/10000));
						cubeArray[i].position.x += dx[i] * 0.01;
						cubeArray[i].position.x *= 1.01 + (tick * .00018);
						cubeArray[i].position.z += dz[i] * 0.01;
						cubeArray[i].rotation.x += xRotation[i] *.001;
						cubeArray[i].rotation.y += yRotation[i] *.001;
						cubeArray[i].rotation.z += zRotation[i] *.001;
					}

					camera.position.z = fixed;
					tick += 1;
					dy *= .5;
				}

				cube.rotation.x += 0.022;
				cube.rotation.y += 0.01;
				cube.rotation.z += 2*tick*tick/10000;
				cube.position.x += .11;
				cube.position.z = cube.position.z * 1.01 + .01;
				cube.position.y += .01*Math.sin(cube.position.z)*Math.sin(cube.position.z)+.1;
				picture.rotation.y = Math.PI/2;
				picture.position.z += .3;
				renderer.render( scene, camera );
			}

			function update() {
				console.log("Position before update: ", position);
				position = new THREE.Vector3();
				position.subVectors( boundingBox.max, boundingBox.min );
				position.multiplyScalar( 0.5 );
				position.add( boundingBox.min );

				position.applyMatrix4( boxshit.matrixWorld );
				cube2 = new THREE.Line( position, cubeGeometry, dashMaterial);
				console.log("Position after update: ", position);
				console.log("boxshit after update: ", boxshit);
				// var cube3 = new THREE.Box3(cube);
				// scene.add(cube3);
				
				cube2.verticesNeedUpdate = true;
				boxshit.elementsNeedUpdate = true;
				boxshit.__dirtyVertices = true;
			
				boxshit.dynamic = true;
				cube2.position.set(position)
				
			}

		</script>
		</div>
		</var>


		<div id="text">
			<p>I build websites that are easy to find, tell a good story, are thoughtfully constructed, and technically excellent. I do apologize to desktop users about my pet cube. He gets a little excited around new people!<p>
			</div>

	</body>
</html>

